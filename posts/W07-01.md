---
title: ðŸ’¥ Chaos & Dysfunction - Revisiting Interaction
published_at: 2025-04-29
snippet: Week 07 01
disable_html_sanitization: true
allow_math: true
---

<style>
  @import url('https://fonts.googleapis.com/css2?family=Cutive+Mono&display=swap');
  @import url('https://use.typekit.net/jyw5vxq.css');

h1, h3, h4, p, pre, ul, li, .notranslate {
  /* font-family: "Cutive Mono", monospace;
  font-weight: 700;
  font-style: normal; */

  font-family: "prestige-elite-std", monospace;
  font-weight: 600;
  font-style: normal;
  color:#CEB5D4;
}

 .text-gray-500, .markdown-body blockquote {color:#E872B0}
 .markdown-body {background-color:#102B53;}
  html {background-color:#102B53;}
  h1 {; font-weight: 800;}
  p, pre, ul {color:#7D9FC0;}
  .markdown-body a {color:#4E7AB1; text-decoration:underline;}

  .notranslate, text {
    color: #102B53;
    font-weight: 800;
  }


</style>

---

# Homework

### 1. In her essay onÂ [Sianne Ngai: Zany, Cute, Interesting](https://rmit.instructure.com/courses/151099/files?preview=44370688), McKenzie Wark writes: "Unlike the interesting, the zany really worksÂ *against*Â its constraints."Â 

> - What do you think she means by this?
> - In what ways would you consider theÂ chaoticÂ and theÂ zanyÂ to be similar?Â  In what ways are they different?
> - In what ways would you consider your AT2 to beÂ zany?
> - What might be some ways to make your AT2Â moreÂ zany?

McKenzie mentions how the three categories fall within a spectrum between play and labour, and where the zany is about the subject and production. Relating back to the idea of effective complexity, play is like the random and labour the structure. Falling closer to the end of the spectrum of labour, zany however has a performative side that makes it work against the structure of labour. Reaching a field of effective complexity that teeters on the edge of random, but has enough structure to keep it together. In this way it makes it very similar to chaos, which is all about play and random. But while zany has structure and, therefore intentional, chaos is usually identified by genuine randomness / disorder that may not be deliberate.

I would consider the structure that plays alongside the random in my assignment task what brings the response piece back into the realm of zany rather than free falling into chaos. While the movement, size and shape of the spores are random, the quantity is a structured ratio amount. The lines that connects them and as they pass by each other are also defined by a formal structure too. But most importantly, each spore has the same blueprint code that creates each instance of the spore. Ultimately brining it back into the realm of zany. Similarly could be said about the shader. It might look chaotic as the movement pattern which causes an overlap, creating the moire effect. The moire effect being the main culprit behind the chaos leaning visual, but it follows the same structure, and the overall rotation of the whole torus is also following a linear rotation route. Making the shader background also fall within the register of zany.

To further make the assignment look even more zany, I think adding more structured disorganisation would further emphasise a zany approach; making it even more chaos but a chaos that is boxed within constraints.

### 2. Please write an accompaniment to your AT2.Â  Include:

> examples of how and where it uses:
>
> - variables
> - iteration
> - functions
> - boolean logic
> - arrays
> - classes
> - recursion
> - how it responds to the chosen text
> - why you consider it to be post-digital

#### Variables

Variables were used plenty of times throughout the code, both global and local. With such a long code I tried to keep things a bit more local in case of accidental crossovers, even though I still made sure all the variables were to be different names. Also being careful with using let and const; always using const for variables that will be declared once and wont change and using let for variables that will be updated through the duration of the code's run time.

A global variable would be like the canvas variable:

```
// setting up canvas
const cnv = document.getElementById(`canvas`);
// setting canvas width + height to window width + height
cnv.width = window.innerWidth;
cnv.height = window.innerHeight;

// getting the 2d context to draw on
const ctx = cnv.getContext(`2d`);
```

And a local variable would be like geometry, which is defined within init().

```
// BACKGROUND
// create a torus knot
const geometry = new THREE.TorusKnotGeometry(5, 3, 40, 15, 14, 4);
// Clear scene of previous meshes if filled
if (mesh) scene.remove(mesh);
// create new instance of mesh with torus knot and shader
mesh = new THREE.Mesh(geometry, shaderMaterial);
// add the mesh to scene
scene.add(mesh);
```

#### Iteration

Iteration allows for the code to be more efficiently written, especially when there is a large amount of objects/steps to go through. This was especially evident for updating each spore on the screen:

```
// update each star particle
particleArr.forEach((e) => {
  e.update();
});
```

And also checking the distance between each spore to determine if a line would be drawn between the two or more:

```
function connect() {
	let opacityVal = 0.7;
	// go through every particle
	for (let a = 0; a < particleArr.length; a++) {
		// if star is glitching skip
		if (particleArr[a].isGlitching) continue;
		// going through consecutive particles in array
			for (let b = 0; b < particleArr.length; b++) {
				// if star is glitching skip
				if (particleArr[b].isGlitching) continue;
				let dist =
				(particleArr[a].x - particleArr[b].x) *
				(particleArr[a].x - particleArr[b].x) +
				(particleArr[a].y - particleArr[b].y) *
				(particleArr[a].y - particleArr[b].y);

				// the smaller the number, the longer the lines,
				// the more particles connected
				if (dist < (cnv.width / 2) * (cnv.height / 2)) {
				opacityVal = 0.7 - dist / 9000;
				ctx.strokeStyle = "rgba(51, 65, 57," + opacityVal + ")";
				ctx.lineWidth = 1;
				//console.log(ctx.lineWidth);
				ctx.beginPath();
				ctx.moveTo(particleArr[a].x, particleArr[a].y);
				ctx.lineTo(particleArr[b].x, particleArr[b].y);
				ctx.stroke();
			}
		}
	}
}
```

#### Functions

Functions pretty much make up the majority of the code, its what hold the actions to be executed when called upon. And on a canvas that is continuously updating frame by frame the functions are continuously being called on the animate function to allow for the movement to show on screen.

```
function animate() {
// call to check global glitch
globalGlitchHandle();

// if global glitch is active
if (globalGlitchEvent === true) {
	// screen colour
	// clearing rect frame
	ctx.clearRect(0, 0, innerWidth, innerHeight);
	// colour
	ctx.fillStyle = "#" + colours[glitchCol];
	// draw rect
	ctx.fillRect(0, 0, innerWidth, innerHeight);
}

// Rotate three.js scene
if (mesh) {
	mesh.rotation.x += 0.005;
	mesh.rotation.y += 0.01;
}

// updating uniform var in shader with the elapsed time of animation
shaderMaterial.uniforms.u_time.value = clock.getElapsedTime();
// render scene
renderer.render(scene, camera);

// update each star particle
particleArr.forEach((e) => {
	e.update();
});

// call the connect func to draw lines
connect();

requestAnimationFrame(animate);
}
```

#### Boolean Logic

Simple binary logic, but important for conditional statements like if else statements where events will only occur if something is either true or false.

```
// if global glitch is active
if (globalGlitchEvent === true) {
	// screen colour
	// clearing rect frame
	ctx.clearRect(0, 0, innerWidth, innerHeight);
	// colour
	ctx.fillStyle = "#" + colours[glitchCol];
	// draw rect
	ctx.fillRect(0, 0, innerWidth, innerHeight);
}
```

#### Arrays

Arrays can hold multiple parameters in one variable, this is a particularly useful way to organise a bunch of parameters that fall within the same category. In AT2 I used it to hold all the instances of the Particle object parameters.

```
// earlier in the code particle array declared
let particleArr = [];

// inside init:
// pushing a new instance of Particle with the above defined values
// into particle array
particleArr.push(new Particle(x, y, dirX, dirY, size, n));
```

Classes
Classes are a way to efficiently create multiple instances of something, as it essentially creates a blueprint for something. I've used this twice for this assignment, one to create the spore, its movement patterns and glitch, but it also calls on another class drawStar which holds the blueprint of drawing a star and its oscillating movement.

```
class drawStar {
	constructor(cx, cy, r1, r2, n) {
		// original x coord
		this.cx = cx;
		// original y coord
		this.cy = cy;
		// new x coord
		this.x = cx;
		// new y coord
		this.y = cy;
		// new inner radius
		this.nR1 = r1;
		// new outer radius
		this.nR2 = r2;
		// current inner radius
		this.r1 = r1;
		// current outer radius
		this.r2 = r2;
		// number of points
		this.n = n;

		// maths
		// starting angle
		this.rot = (Math.PI / 2) * 3;
		// angle between each point
		this.step = Math.PI / n;

		// oscillation par
		// minimum scale factor (50%)
		this.minScale = 0.5;
		// maximum scale factor (150%)
		this.maxScale = 1.5;
		// oscillations per second
		this.freq = 0.5;

		// track start time from when star is created in ms
		this.startT = Date.now();

	}

	// FUNC: TRIANGLE WAVE (0 to 1)
	calcWave() {
		// real elapsed time; seconds
		const elapsedT = (Date.now() - this.startT) / 1000;
		// period = time to create one cycle
		const period = 1 / this.freq;
		// normalized val of time along triangle wave
		const t = (elapsedT % period) / period;
		// If t < 0.5 (first half of the cycle): t * 2 (create line from 0 to 1)
		// If t â‰¥ 0.5 (second half of the cycle): 2 * (1 - t) (create line from 1 down to 0)
		return t < 0.5 ? 2 * t : 2 * (1 - t);
	}



	draw() {
		ctx.beginPath();
		// reset rotation angle for each draw
		this.rot = (Math.PI / 2) * 3;

		// move to starting star point
		ctx.moveTo(this.cx, this.cy - this.r2);
		// keep repeating process until n points (full circle )
		for (let i = 0; i < this.n; i++) {
		// new x , y; next inner corner
		this.x = this.cx + Math.cos(this.rot) * this.r2;
		this.y = this.cy + Math.sin(this.rot) * this.r2;
		ctx.lineTo(this.x, this.y);
		// moving angle along
		this.rot += this.step;

		// new x, y; next outer point
		this.x = this.cx + Math.cos(this.rot) * this.r1;
		this.y = this.cy + Math.sin(this.rot) * this.r1;
		ctx.lineTo(this.x, this.y);
		this.rot += this.step;
	}

	// closing up star
	ctx.lineTo(this.cx, this.cy - this.r2);
	ctx.closePath();

	// fill star
	ctx.fill();

	}



	update() {
		// Calculate the scale factor using triangle wave
		const sig = this.calcWave();
		const scaleF = this.minScale + sig * (this.maxScale - this.minScale);

		// Apply scale to radii
		this.r1 = this.nR1 * scaleF;
		this.r2 = this.nR2 * scaleF;

		this.draw();
	}

	// Method to change oscillation par
	setOscillation(minScale, maxScale, frequency) {
		this.minScale = minScale;
		this.maxScale = maxScale;
		this.freq = frequency;
	}

}
```

#### Recursion

Recursion is also another way to make coding more efficient. In this case I've used it to keep calling on itself until a new random, but different to the previous, colour index number is called upon. And till then it wont return a value.

```
function coliRandomiser(i) {
	// compute random colour index
	// new var to hold new colour index
	let newColi = Math.floor(Math.random() * colours.length);

	// if the new random index == the current index number
	// call the function again to get a new random index number
	// that is different
	if (newColi == i) {
		console.log("call recursive");
		return coliRandomiser(i);
	} else {
		// return new random index
		//newCol= r;
		return newColi;
	}
}
```

#### How it responds to the chosen text and why is it Post-digital?

The aim of my assignment task was to create a response that was a mix of literal and abstract feeling and an interpretation of that feeling that I got from reading the text. It visualises (quite literally) my interpretation of the mycelial network lattice of the academic sector of the text, whilst also giving an interpretation of the feelings I gathered from Sheldrakes more personal anecdote within the text at the end.

In this sense I say this is what also makes the work post-digital. The mycelial network is a very old living concept, whether we were aware of this or not. Taking this and giving it a very literal interpretation (the very first iteration of my assignment response) that was then taken and continuously manipulated; approaching the "old media" with "new media" approaches to deconstruct the "old media" and give it new meaning is why I ultimately would consider my work I've made post-digital.

---

# Assignment 2

<iframe id="w07-01" src="https://sams4m-comm2747-at2.deno.dev/ver3/"></iframe>

> Third implementation of AT2.

<div id="codeblock0"> </div>

I had moved the shader into a seperate js file to import in instead due to how long the code was getting. This way it would make it easier for me to find my way through the code.

In an attempt to remedy the issue of the screen eventually being covered and shader no longer to be seen, I thought to implement glitch to the code. I started with implementing it on the stars itself, causing it to randomly stop and start again. This is specifically in response to the excerpt:

> "FUNGI ARE EVERYWHERE but they are easy to miss. ... The more we learn about fungi, the less makes sense without them." (pg1)

In a more literal sense. The subtle glitch of random spores stopping and starting is meant to not be very noticeable since theres spores everywhere. And once I got that to work I wanted to implement a global glitch that would stop and would cause the screen to glitch to another colour and essentially restart the scene at random intervals, as another literal response to the second half where "the less makes sense without them" as they screen is wiped from probably the only thing that very obviously visualises a structural pattern. But also affectively resolving the problem of the screen being covered by the spores and shader no longer being visible. Killing two birds with one stone here. The interaction is also added to the click event handler, where there is a 20% chance for the global glitch to occur on click in an attempt to pull the glitch and assignment back more zany.

<iframe id="w07-02" src="https://sams4m-comm2747-at2.deno.dev/ver4/"></iframe>

> Fourth implementation of AT2.

<div id="codeblock1"> </div>

From here I made one final iteration of the code; I adjusted how sound was implemented in the code. I've never really worked with manipulating sound in javascript so I didn't really know what I was doing before when I first added sound. After the last class it gave me an idea to make the code even more structurally chaotic (zany) I could implement a variation of what was made for homework last lesson. I added the a click handler for the sound, where once the sound started playing after initial interaction to resume the sound it manipulated the audio gain and applied a sinusoidal wave on it where the frequency also had a randomised factor to it. Every time a click was initiated it would change the state of the sound from on to off and vice-versa. The aim being de-familarising the sourced sound and ensuing more contained chaos!

<iframe id="w07-03" src="https://sams4m-comm2747-at2.deno.dev/"></iframe>

> Fourth implementation of AT2.

<div id="codeblock2"> </div>

<script type="module">
const iframe = document.getElementById (`w07-01`)
iframe.width = iframe.parentNode.scrollWidth
iframe.height = iframe.width * 9 / 16 + 42
</script>

<script type="module">
const iframe = document.getElementById (`w07-02`)
iframe.width = iframe.parentNode.scrollWidth
iframe.height = iframe.width * 9 / 16 + 42
</script>

<script type="module">
const iframe = document.getElementById (`w07-03`)
iframe.width = iframe.parentNode.scrollWidth
iframe.height = iframe.width * 9 / 16 + 42
</script>

---

<script type="module">
   import codeBlockRenderer from "/scripts/codeblock_renderer.js"
   codeBlockRenderer (document, `ver3`, `codeblock0`)
</script>

<script type="module">
   import codeBlockRenderer from "/scripts/codeblock_renderer.js"
   codeBlockRenderer (document, `ver4`, `codeblock1`)
</script>

<script type="module">
   import codeBlockRenderer from "/scripts/codeblock_renderer.js"
   codeBlockRenderer (document, `fin`, `codeblock2`)
</script>

<!-- FIN SCRIPT -------------------------------------------------------------------- -->
<script type="module" id="fin">
// ----------------------------------------------------------------------- //
// IMPORTS
import { drawStar } from "/drawStar.js";
import { colours } from "./colour.js";
import { shaderMaterial } from "./shader.js";
import * as THREE from "/three.js";

// ----------------------------------------------------------------------- //
// SET UP
// document styling
document.body.style.margin = 0;
document.body.style.overflow = `hidden`;

// setting up canvas
const cnv = document.getElementById(`canvas`);
// setting canvas width + height to window width + height
cnv.width = window.innerWidth;
cnv.height = window.innerHeight;

// getting the 2d context to draw on
const ctx = cnv.getContext(`2d`);

// setting up 3D scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x7252dc);
const camera = new THREE.PerspectiveCamera(
  50,
  cnv.width / cnv.height,
  0.01,
  10
);
camera.position.z = 2;
// declaring time stamp
const clock = new THREE.Clock();

// Setup renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
// size of renderer
renderer.setSize(window.innerWidth, window.innerHeight);
// adding renderer to dom
document.body.appendChild(renderer.domElement);

// renderer styling
renderer.domElement.style.position = "absolute";
renderer.domElement.style.top = "0";
renderer.domElement.style.left = "0";
renderer.domElement.style.zIndex = "-1";

// ----------------------------------------------------------------------- //
// SOUND
const audioContext = new AudioContext();
// suspend until click
audioContext.suspend();

// define an async click handler function
async function initAudio() {
  // wait for audio context to resume
  await audioContext.resume();
  // play audio element
  audioE.play();
  // set looping to true
  audioE.loop = true;
}

// volume controls
const gainNode = audioContext.createGain();
// audio element
const audioE = new Audio("weird.wav");
// pre load sound immediatly
audioE.load();
// declare source var
const source = audioContext.createMediaElementSource(audioE);
// connect audio element to gain node
source.connect(gainNode);
// Connect Gain Node to Destination
gainNode.connect(audioContext.destination);
// preset value ; set at 50%
gainNode.gain.value = 0.5;

// amplitude modulation variables
let modulationStartTime = 0;
// 1 / random value between 2-7 Hz frequency
const modulationFrequency = (1 / Math.random()) * (7 - 2 + 2);

// TOGGLE SOUND
// define a sound status var
let soundStatus = false;

// toggle sound function
function toggleSound() {
  // if sound status value is off
  if (soundStatus === false) {
    // modulation start time
    modulationStartTime = audioContext.currentTime;

    // set the value to true
    soundStatus = true;

    let soundRatio = mouse.x / cnv.width;

    gainNode.gain.value = gainNode.gain.value * soundRatio;

    // start amplitude modulation
    modulateAmplitude();
  }
  // if sound status value is on
  else if (soundStatus === true) {
    // set the value to false
    soundStatus = false;
  }
}

// anonymous function click handler
cnv.onclick = () => {
  // if the audio context is still suspended
  // resume the audio context first
  if (audioContext.state != "running") initAudio();

  // then call the toggle sound function
  toggleSound();
};

// function to apply amplitude modulation
function modulateAmplitude() {
  // declaring time now when function called
  const now = audioContext.currentTime;
  // calculating elapsed time
  const elapsedTime = now - modulationStartTime;

  // modulation - creates values between 0 and 1
  // starting from the middle 0.5
  // sin produces a wave between -1 and 1
  // therefore * 0.5 to make it -0.5 to 0.5
  // +0.5 makes ot 0 to 1
  // angle = 2 * Math.PI * modulationFrequency * elapsedTime
  // 2 * Math.PI = full circle
  // modulationFrequecy = 1/24 means we complete a cycle every 24 s
  // elapsedTime = time since we started oscillation
  const modulation =
    0.5 + 0.5 * Math.sin(2 * Math.PI * modulationFrequency * elapsedTime);

  // apply to gain (with base amplitude of 0.2)
  gainNode.gain.value = 0.2 * modulation;

  // next modulation update
  if (soundStatus === true) {
    requestAnimationFrame(modulateAmplitude);
  } else {
    gainNode.gain.value = 0;
  }
}

// ----------------------------------------------------------------------- //
// GLOBAL VARS
// declaring vars for: particle array, colour index, mesh, glitch colour index
let particleArr = [],
  coli = 0,
  mesh,
  glitchCol;

// GLOBAL GLITCH
// set default as not glitching
let globalGlitchEvent = false;
// initialise glitch in 10-25 seconds
let nextGlobalGlitchTime =
  clock.getElapsedTime() * 1000 + (Math.random() * 15000 + 10000);
// initialise end time = 0
let globalGlitchEndTime = 0;

// MOUSE OBJ; tracks mouse x, y coord
// grab mouse position
let mouse = {
  x: null,
  y: null,
  // the radius will give the particles an area around the
  // mouse which they interact/react with
  radius: (cnv.height / 170) * (cnv.width / 170),
};

// event listener will fire every time the mouse moves and
// fills the mouse object
window.addEventListener("mousemove", function (event) {
  mouse.x = event.x;
  mouse.y = event.y;
});

// ----------------------------------------------------------------------- //
// CLASS: PARTICLE
class Particle {
  constructor(x, y, dirX, dirY, size, npoint) {
    // movement related properties
    // x coordinate
    this.x = x;
    // y coordinate
    this.y = y;
    // velocity along x
    this.dirX = dirX;
    // velocity along y
    this.dirY = dirY;
    // particle size
    this.size = size;

    // glitch related properties
    // set initial state to false
    this.isGlitching = false;
    // set initial time using Three.js clock
    const startTime = clock.getElapsedTime() * 1000;
    // set first glitch to happen between 2 - 10 seconds from now
    this.nextGlitchTime = startTime + (Math.random() * (60000 - 2000) + 2000);
    // defined when glitching starts
    this.glitchEndTime = 0;

    // star particle
    // number of points on star
    this.n = npoint;
    // calling class to create a new iteration of star
    this.starParticle = new drawStar(
      this.x,
      this.y,
      this.size - 2,
      this.size + 7,
      this.n
    );

    // star oscillation
    // setOscillation(minScale 0.7,
    // maxScale random val between 2.5 and 3, frequency)
    this.starParticle.setOscillation(
      0.7,
      Math.random() * (3 - 2.5) + 2.5,
      0.2 + Math.random() * 0.6
    );
  }

  // method to draw an individual particle
  draw() {
    // only draw if not glitching
    if (!this.isGlitching) {
      // colour
      let colour = "#" + colours[coli];
      ctx.fillStyle = colour;

      // Update star position to match particle
      this.starParticle.cx = this.x;
      this.starParticle.cy = this.y;

      // calling update
      this.starParticle.update();
    }
  }

  // METHOD: glitch effect
  glitchHandle() {
    // get current time in ms
    const currentTime = clock.getElapsedTime() * 1000;

    // if currently glitching
    if (this.isGlitching) {
      // check if glitch duration is over by comparing timestamps
      // if more than end time means glitch period ended
      if (currentTime > this.glitchEndTime) {
        // glitch = false
        this.isGlitching = false;
        // set next glitch time in 2 - 10 seconds
        this.nextGlitchTime =
          currentTime + (Math.random() * (60000 - 2000) + 2000);
        // set a new x and y coord within canvas with 5px boundary
        this.x = Math.random() * (cnv.width - 5 - 5 + 5);
        this.y = Math.random() * (cnv.height - 5 - 5 + 5);
      }
    }
    // if not glitching - check if time to glitch
    // if current time stamp is greater than next glitch time
    // means should be glitching
    else if (currentTime > this.nextGlitchTime) {
      this.isGlitching = true;
      // set glitch to randomly end in 2 - 6 seconds
      this.glitchEndTime =
        currentTime + (Math.random() * (60000 - 2000) + 2000);
    }
  }

  // check glitch status, particle pos, mouse pos, move the particle and draw
  update() {
    // call glitch handle method
    this.glitchHandle();

    // check particle is still within canvas
    if (this.x > cnv.width || this.x < 0) {
      // turn direction around
      this.dirX = -this.dirX;
    }
    if (this.y > cnv.height || this.y < 0) {
      // turn direction around
      this.dirY = -this.dirY;
    }

    // check for collision detection between mouse & particles
    // circle collision
    // ref: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection

    // checking distance between mouse & particle center point
    let dx = mouse.x - this.x;
    let dy = mouse.y - this.y;

    // a^2 + b^2 = c^2
    let dist = Math.sqrt(dx * dx + dy * dy);

    // checking that particle is far enough from edge of cvs
    // or it'll get stuck
    if (dist < mouse.radius + this.size) {
      // allowing buffer area of particle size (this.size) * 10
      // if mouse is left of particle
      if (mouse.x < this.x && this.x < cnv.width - this.size * 10) {
        // move particle to the right
        this.x += 10;
      }
      // if mouse is right of particle
      if (mouse.x > this.x && this.x > this.size * 10) {
        // move particle to the left
        this.x -= 10;
      }
      // if mouse is above particle
      if (mouse.y < this.y && this.y < cnv.height - this.size * 10) {
        // move particle down
        this.y += 10;
      }
      // if mouse is under particle
      if (mouse.y > this.y && this.y > this.size * 10) {
        // move particle up
        this.x -= 10;
      }
    }
    // moving all the other particles that aren't colliding along too
    this.x += this.dirX;
    this.y += this.dirY;
    // calling draw method to update;
    this.draw();
  }
}

// ----------------------------------------------------------------------- //
// INITIALISE
function init() {
  // number of particles
  let numOf = (cnv.height * cnv.width) / 7000;

  // loop to create values to create instaces of Particle to push into array
  // till num of particles reached
  for (let i = 0; i < numOf; i++) {
    // size of particle = random val between 1 & 5
    let size = Math.random() * (5 - 1) + 1;
    // x coord = random value between 0 and cnv width
    // with size * 2 as buffer so it doesn't get stuck
    let x =
      Math.random() * (cnv.width - size * 2 - (0 + size * 2)) + 0 + size * 2;
    let y =
      Math.random() * (cnv.height - size * 2 - (0 + size * 2)) + 0 + size * 2;

    // particle movement speed between -0.5 and 0.5
    let dirX = Math.random() * (1 + 0.5) - 0.5;
    let dirY = Math.random() * (1 + 0.5) - 0.5;

    // number of points on star
    // random value between 7 and 15
    let n = Math.random() * (15 - 7) + 7;

    // pushing a new instance of Particle with the above defined values
    // into particle array
    particleArr.push(new Particle(x, y, dirX, dirY, size, n));
  }

  // BACKGROUND
  // create a torus knot
  const geometry = new THREE.TorusKnotGeometry(5, 3, 40, 15, 14, 4);
  // Clear scene of previous meshes if filled
  if (mesh) scene.remove(mesh);
  // create new instance of mesh with torus knot and shader
  mesh = new THREE.Mesh(geometry, shaderMaterial);
  // add the mesh to scene
  scene.add(mesh);

  // add light
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
}

// ----------------------------------------------------------------------- //
// ANIMATION LOOP
function animate() {
  // call to check global glitch
  globalGlitchHandle();

  // if global glitch is active
  if (globalGlitchEvent === true) {
    // screen colour
    // clearing rect frame
    ctx.clearRect(0, 0, innerWidth, innerHeight);
    // colour
    ctx.fillStyle = "#" + colours[glitchCol];
    // draw rect
    ctx.fillRect(0, 0, innerWidth, innerHeight);
  }

  // Rotate three.js scene
  if (mesh) {
    mesh.rotation.x += 0.005;
    mesh.rotation.y += 0.01;
  }

  // updating uniform var in shader with the elapsed time of animation
  shaderMaterial.uniforms.u_time.value = clock.getElapsedTime();
  // render scene
  renderer.render(scene, camera);

  // update each star particle
  particleArr.forEach((e) => {
    e.update();
  });

  // call the connect func to draw lines
  connect();

  requestAnimationFrame(animate);
}

// call init fill array with randomised particles
init();
// call animate
animate();

// ----------------------------------------------------------------------- //
// web responsive
onresize = () => {
  cnv.width = innerWidth;
  cnv.height = innerHeight;
  mouse.radius = (cnv.height / 170) * (cnv.width / 170);

  // Update renderer and camera
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  init();
};

// ----------------------------------------------------------------------- //
// mouse out event
// particles stop trying to interact with mouse when it leaves canvas
window.addEventListener("mouseout", function (mouse_event) {
  mouse.x = undefined;
  mouse.y = undefined;
});

// ----------------------------------------------------------------------- //
// CLICK EVENT HANDLER
cnv.addEventListener("click", function cnvClicked() {
  console.log("screen clicked");
  // COLOUR
  // change colour index
  coli = coliRandomiser(coli);
  console.log(coli);

  // GLITCH (20% CHANCE)
  if (Math.random() < 0.2 && !globalGlitchEvent) {
    console.log("glitch is true");
    // start glitch
    globalGlitchEvent = true;
    // setting random background colour
    glitchCol = coliRandomiser(glitchCol);
    console.log(glitchCol);
    // set a random end time between 500-1500ms
    globalGlitchEndTime =
      clock.getElapsedTime() * 1000 + (Math.random() * (1500 - 500) + 500);
  }
});

// ----------------------------------------------------------------------- //
// FUNC: CONNECT
// checking if particles are close enough to connect
function connect() {
  let opacityVal = 0.7;
  // go through every particle
  for (let a = 0; a < particleArr.length; a++) {
    // if star is glitching skip
    if (particleArr[a].isGlitching) continue;
    // going through consecutive particles in array
    for (let b = 0; b < particleArr.length; b++) {
      // if star is glitching skip
      if (particleArr[b].isGlitching) continue;
      let dist =
        (particleArr[a].x - particleArr[b].x) *
          (particleArr[a].x - particleArr[b].x) +
        (particleArr[a].y - particleArr[b].y) *
          (particleArr[a].y - particleArr[b].y);

      // the smaller the number, the longer the lines,
      // the more particles connected
      if (dist < (cnv.width / 2) * (cnv.height / 2)) {
        opacityVal = 0.7 - dist / 9000;
        ctx.strokeStyle = "rgba(51, 65, 57," + opacityVal + ")";
        ctx.lineWidth = 1;
        //console.log(ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(particleArr[a].x, particleArr[a].y);
        ctx.lineTo(particleArr[b].x, particleArr[b].y);
        ctx.stroke();
      }
    }
  }
}

// ----------------------------------------------------------------------- //
// FUNC: GLOBAL ANIMATION GLITCH HANDLE
function globalGlitchHandle() {
  // get current time in ms
  const currentTime = clock.getElapsedTime() * 1000;

  // If glitch is active
  if (globalGlitchEvent === true) {
    // check if glitch should end
    // if current time is greater than end time
    if (currentTime > globalGlitchEndTime) {
      // set glitch to false
      globalGlitchEvent = false;

      // restart the animation
      console.log("restarting animation");

      // clear particle array
      particleArr = [];

      // Clear scene
      if (mesh) scene.remove(mesh);

      // clear 2d ctx
      ctx.clearRect(0, 0, innerWidth, innerHeight);

      // re-initialize everything
      init();

      // Set next global glitch time - random val between 15-30 seconds
      nextGlobalGlitchTime =
        currentTime + (Math.random() * (30000 - 15000) + 15000);
    }
  }
  // if not in a global glitch state
  // check if current time is more than next glitch time
  // meaning it should be glitching
  else if (currentTime > nextGlobalGlitchTime) {
    console.log("global glitch true");
    // set glitch event to true
    globalGlitchEvent = true;

    // setting random background colour
    glitchCol = coliRandomiser(glitchCol);
    console.log(glitchCol);

    // set a random end time between 500ms-2s
    globalGlitchEndTime = currentTime + (Math.random() * (2000 - 500) + 500);
  }
}

// ----------------------------------------------------------------------- //
// FUNC: RANDOM COLOUR INDEX
function coliRandomiser(i) {
  // compute random colour index
  // new var to hold new colour index
  let newColi = Math.floor(Math.random() * colours.length);

  // if the new random index == the current index number
  // call the function again to get a new random index number
  // that is different
  if (newColi == i) {
    console.log("call recursive");
    return coliRandomiser(i);
  } else {
    // return new random index
    //newCol= r;
    return newColi;
  }
}
</script>

<!-- VER 3 SCRIPT -------------------------------------------------------------------- -->
<script type="module" id="ver3">
import { drawStar } from "/drawStar.js";
import { colours } from "./colour.js";
import { shaderMaterial } from "./shader.js";
import * as THREE from "/three.js";
import { OrbitControls } from "/OrbitControls.js";

// document styling
document.body.style.margin = 0;
document.body.style.overflow = `hidden`;

// setting up canvas
const cnv = document.getElementById(`canvas`);
cnv.width = window.innerWidth;
cnv.height = window.innerHeight;

const ctx = cnv.getContext(`2d`);

// Set up scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x7252dc);
const camera = new THREE.PerspectiveCamera(
  50,
  cnv.width / cnv.height,
  0.01,
  10
);
camera.position.z = 2;
const renderer = new THREE.WebGLRenderer({ antialias: true });
const clock = new THREE.Clock();

// Setup renderer
// size of renderer
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// styling
renderer.domElement.style.position = "absolute";
renderer.domElement.style.top = "0";
renderer.domElement.style.left = "0";
renderer.domElement.style.zIndex = "-1";

// set up orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ----------------------------------------------------------------------- //
// sound
const audioContext = new AudioContext();
// suspend until click
audioContext.suspend();
// volume controls
const gainNode = audioContext.createGain();
// audio
const audioE = new Audio("/weird.wav");
audioE.load();
const source = audioContext.createMediaElementSource(audioE);
// connect audio element to gain node
source.connect(gainNode);
// Connect Gain Node to Destination
gainNode.connect(audioContext.destination);
// preset value ; set at 50%
gainNode.gain.value = 0.5;

// ----------------------------------------------------------------------- //
// GLOBAL VARS
let particleArr = [],
  coli = 0,
  mesh;

// MOUSE OBJ; tracks mouse x, y coord
// grab mouse position
let mouse = {
  x: null,
  y: null,
  // the radius will give the particles an area around the
  // mouse which they interact/react with
  radius: (cnv.height / 200) * (cnv.width / 200),
};

// event listener will fire every time the mouse moves and
// fills the mouse object
window.addEventListener("mousemove", function (event) {
  mouse.x = event.x;
  mouse.y = event.y;
});

// ----------------------------------------------------------------------- //
// CLASS: PARTICLE
class Particle {
  constructor(x, y, dirX, dirY, size, npoint) {
    // movement related properties
    // x coordinate
    this.x = x;
    // y coordinate
    this.y = y;
    // velocity along x
    this.dirX = dirX;
    // velocity along y
    this.dirY = dirY;
    // particle size
    this.size = size;

    // glitch related properties
    // set initial state to false
    this.isGlitching = false;
    // set initial time using Three.js clock
    const startTime = clock.getElapsedTime() * 1000;
    // set first glitch to happen between 2 - 10 seconds from now
    this.nextGlitchTime = startTime + (Math.random() * (60000 - 2000) + 2000);
    // defined when glitching starts
    this.glitchEndTime = 0;

    // star particle
    // number of points on star
    this.n = npoint;
    this.starParticle = new drawStar(
      this.x,
      this.y,
      this.size - 2,
      this.size + 7,
      this.n
    );

    // star oscillation
    // setOscillation(minScale 0.7,
    // maxScale random val between 2.5 and 3, frequency)
    this.starParticle.setOscillation(
      0.7,
      Math.random() * (3 - 2.5) + 2.5,
      0.2 + Math.random() * 0.6
    );
  }

  // method to draw an individual particle
  draw() {
    // only draw if not glitching
    if (!this.isGlitching) {
      // colour
      let colour = "#" + colours[coli];
      ctx.fillStyle = colour;

      // Update star position to match particle
      this.starParticle.cx = this.x;
      this.starParticle.cy = this.y;

      // calling update
      this.starParticle.update();
    }
  }

  // METHOD: glitch effect
  glitchHandle() {
    // get current time in ms
    const currentTime = clock.getElapsedTime() * 1000;

    // if currently glitching
    if (this.isGlitching) {
      // check if glitch duration is over by comparing timestamps
      // if more than duration (end time)
      if (currentTime > this.glitchEndTime) {
        // glitch = false
        this.isGlitching = false;
        // set next glitch time in 2 - 10 seconds
        this.nextGlitchTime =
          currentTime + (Math.random() * (60000 - 2000) + 2000);
      }
    }
    // if not glitching - check if time to glitch
    // if current time stamp is greater than next glitch time
    // means should be glitching
    else if (currentTime > this.nextGlitchTime) {
      this.isGlitching = true;
      // set glitch end time; random between 2 - 10 seconds
      this.glitchEndTime =
        currentTime + (Math.random() * (60000 - 2000) + 2000);
    }
  }

  // check particle pos, mouse pos, move the particle and draw
  update() {
    // call glitch handle method
    this.glitchHandle();

    // check particle is still within canvas
    if (this.x > cnv.width || this.x < 0) {
      // turn direction around
      this.dirX = -this.dirX;
    }
    if (this.y > cnv.height || this.y < 0) {
      // turn direction around
      this.dirY = -this.dirY;
    }

    // check for collision detection between mouse & particles
    // circle collision
    // ref: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection

    // checking distance between mouse & particle center point
    let dx = mouse.x - this.x;
    let dy = mouse.y - this.y;

    // a^2 + b^2 = c^2
    let dist = Math.sqrt(dx * dx + dy * dy);

    // checking that particle is far enough from edge of cvs
    // or it'll get stuck
    if (dist < mouse.radius + this.size) {
      // allowing buffer area of particle size (this.size) * 10
      // if mouse is left of particle
      if (mouse.x < this.x && this.x < cnv.width - this.size * 10) {
        // move particle to the right
        this.x += 10;
      }
      // if mouse is right of particle
      if (mouse.x > this.x && this.x > this.size * 10) {
        // move particle to the left
        this.x -= 10;
      }
      // if mouse is above particle
      if (mouse.y < this.y && this.y < cnv.height - this.size * 10) {
        // move particle down
        this.y += 10;
      }
      // if mouse is under particle
      if (mouse.y > this.y && this.y > this.size * 10) {
        // move particle up
        this.x -= 10;
      }
    }
    // moving all the other particles that aren't colliding along too
    this.x += this.dirX;
    this.y += this.dirY;
    // calling draw method to update;
    this.draw();
  }
}

// ----------------------------------------------------------------------- //
// INIT: RANDOMISE VALUES FOR PARTICLES
function init() {
  // number of particles
  let numOf = (cnv.height * cnv.width) / 8000;

  for (let i = 0; i < numOf; i++) {
    // size of particle = random val between 1 & 5
    let size = Math.random() * (5 - 1) + 1;
    // x coord = random value between 0 and cnv width
    // with size * 2 as buffer so it doesn't get stuck
    let x =
      Math.random() * (cnv.width - size * 2 - (0 + size * 2)) + 0 + size * 2;
    let y =
      Math.random() * (cnv.height - size * 2 - (0 + size * 2)) + 0 + size * 2;

    // particle movement speed between -0.5 and 0.5
    let dirX = Math.random() * (1 + 0.5) - 0.5;
    let dirY = Math.random() * (1 + 0.5) - 0.5;

    // number of points on star
    // random value between 7 and 15
    let n = Math.random() * (15 - 7) + 7;

    // pushing a new instance of Particle with the above defined values
    // into particle array
    particleArr.push(new Particle(x, y, dirX, dirY, size, n));
  }

  // // create a torus knot
  const geometry = new THREE.TorusKnotGeometry(5, 3, 40, 15, 14, 4);
  mesh = new THREE.Mesh(geometry, shaderMaterial);
  // Clear scene of previous meshes
  if (mesh) scene.remove(mesh);
  scene.add(mesh);

  // add light
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
}

// FUNC: CONNECT
// checking if particles are close enough to connect
function connect() {
  let opacityVal = 0.7;
  // go through every particle
  for (let a = 0; a < particleArr.length; a++) {
    // if star is glitching skip
    if (particleArr[a].isGlitching) continue;
    // going through consecutive particles in array
    for (let b = 0; b < particleArr.length; b++) {
      // if star is glitching skip
      if (particleArr[b].isGlitching) continue;
      let dist =
        (particleArr[a].x - particleArr[b].x) *
          (particleArr[a].x - particleArr[b].x) +
        (particleArr[a].y - particleArr[b].y) *
          (particleArr[a].y - particleArr[b].y);

      // the smaller the number, the longer the lines,
      // the more particles connected
      if (dist < (cnv.width / 2) * (cnv.height / 2)) {
        opacityVal = 0.7 - dist / 9000;
        ctx.strokeStyle = "rgba(51, 65, 57," + opacityVal + ")";
        ctx.lineWidth = 1;
        //console.log(ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(particleArr[a].x, particleArr[a].y);
        ctx.lineTo(particleArr[b].x, particleArr[b].y);
        ctx.stroke();
      }
    }
  }
}

// ----------------------------------------------------------------------- //

// ANIMATION LOOP
function animate() {
  // Rotate three.js scene
  if (mesh) {
    mesh.rotation.x += 0.005;
    mesh.rotation.y += 0.01;
  }

  // updating uniform var in shader with the elapsed time of animation
  shaderMaterial.uniforms.u_time.value = clock.getElapsedTime();
  // render scene
  renderer.render(scene, camera);

  // update orbit controls
  controls.update();

  // update each star particle
  particleArr.forEach((e) => {
    e.update();
  });

  // call the connect func to draw lines
  connect();

  requestAnimationFrame(animate);
}

// call init fill array with randomised particles
init();
// call animate
animate();

// ----------------------------------------------------------------------- //
// web responsive
onresize = () => {
  cnv.width = innerWidth;
  cnv.height = innerHeight;
  mouse.radius = (cnv.height / 200) * (cnv.width / 200);

  // Update renderer and camera
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  init();
};

// mouse out event
// particles stop trying to interact with mouse when it leaves canvas
window.addEventListener("mouseout", function (mouse_event) {
  mouse.x = undefined;
  mouse.y = undefined;
});

// new var to hold new colour index
let newColi;
cnv.addEventListener("click", function cnvClicked() {
  console.log("screen clicked");
  // COLOUR
  // change colour index
  coli = coliRandomiser();
  console.log(coli);

  // SOUND
  if (audioContext.state == "suspended") {
    audioContext.resume();
  } else {
    audioE.play();
    let soundRatio = mouse.x / cnv.width;

    gainNode.gain.value = soundRatio;
  }
});

// FUNC: RANDOM COLOUR INDEX
function coliRandomiser() {
  // compute random colour index
  newColi = Math.floor(Math.random() * colours.length);

  // if the new random index == the current index number
  // call the function again to get a new random index number
  // that is different
  if (newColi == coli) {
    console.log("call recursive");
    return coliRandomiser();
  } else {
    // return new random index
    //randCol= r;
    return newColi;
  }
}
</script>

<!-- VER 4 SCRIPT -------------------------------------------------------------------- -->
<script type="module" id="ver4">
// ----------------------------------------------------------------------- //
// IMPORTS
import { drawStar } from "/drawStar.js";
import { colours } from "./colour.js";
import { shaderMaterial } from "./shader.js";
import * as THREE from "/three.js";

// ----------------------------------------------------------------------- //
// SET UP
// document styling
document.body.style.margin = 0;
document.body.style.overflow = `hidden`;

// setting up canvas
const cnv = document.getElementById(`canvas`);
// setting canvas width + height to window width + height
cnv.width = window.innerWidth;
cnv.height = window.innerHeight;

// getting the 2d context to draw on
const ctx = cnv.getContext(`2d`);

// setting up 3D scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x7252dc);
const camera = new THREE.PerspectiveCamera(
  50,
  cnv.width / cnv.height,
  0.01,
  10
);
camera.position.z = 2;
// declaring time stamp
const clock = new THREE.Clock();

// Setup renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
// size of renderer
renderer.setSize(window.innerWidth, window.innerHeight);
// adding renderer to dom
document.body.appendChild(renderer.domElement);

// renderer styling
renderer.domElement.style.position = "absolute";
renderer.domElement.style.top = "0";
renderer.domElement.style.left = "0";
renderer.domElement.style.zIndex = "-1";

// ----------------------------------------------------------------------- //
// SOUND
const audioContext = new AudioContext();
// suspend until click
audioContext.suspend();
// volume controls
const gainNode = audioContext.createGain();
// audio
const audioE = new Audio("/weird.wav");
audioE.load();
const source = audioContext.createMediaElementSource(audioE);
// connect audio element to gain node
source.connect(gainNode);
// Connect Gain Node to Destination
gainNode.connect(audioContext.destination);
// preset value ; set at 50%
gainNode.gain.value = 0.5;

// ----------------------------------------------------------------------- //
// GLOBAL VARS
// declaring vars for: particle array, colour index, mesh, glitch colour index
let particleArr = [],
  coli = 0,
  mesh,
  glitchCol;

// GLOBAL GLITCH
// set default as not glitching
let globalGlitchEvent = false;
// initialise glitch in 10-25 seconds
let nextGlobalGlitchTime =
  clock.getElapsedTime() * 1000 + (Math.random() * 15000 + 10000);
// initialise end time = 0
let globalGlitchEndTime = 0;

// MOUSE OBJ; tracks mouse x, y coord
// grab mouse position
let mouse = {
  x: null,
  y: null,
  // the radius will give the particles an area around the
  // mouse which they interact/react with
  radius: (cnv.height / 170) * (cnv.width / 170),
};

// event listener will fire every time the mouse moves and
// fills the mouse object
window.addEventListener("mousemove", function (event) {
  mouse.x = event.x;
  mouse.y = event.y;
});

// ----------------------------------------------------------------------- //
// CLASS: PARTICLE
class Particle {
  constructor(x, y, dirX, dirY, size, npoint) {
    // movement related properties
    // x coordinate
    this.x = x;
    // y coordinate
    this.y = y;
    // velocity along x
    this.dirX = dirX;
    // velocity along y
    this.dirY = dirY;
    // particle size
    this.size = size;

    // glitch related properties
    // set initial state to false
    this.isGlitching = false;
    // set initial time using Three.js clock
    const startTime = clock.getElapsedTime() * 1000;
    // set first glitch to happen between 2 - 10 seconds from now
    this.nextGlitchTime = startTime + (Math.random() * (60000 - 2000) + 2000);
    // defined when glitching starts
    this.glitchEndTime = 0;

    // star particle
    // number of points on star
    this.n = npoint;
    // calling class to create a new iteration of star
    this.starParticle = new drawStar(
      this.x,
      this.y,
      this.size - 2,
      this.size + 7,
      this.n
    );

    // star oscillation
    // setOscillation(minScale 0.7,
    // maxScale random val between 2.5 and 3, frequency)
    this.starParticle.setOscillation(
      0.7,
      Math.random() * (3 - 2.5) + 2.5,
      0.2 + Math.random() * 0.6
    );
  }

  // method to draw an individual particle
  draw() {
    // only draw if not glitching
    if (!this.isGlitching) {
      // colour
      let colour = "#" + colours[coli];
      ctx.fillStyle = colour;

      // Update star position to match particle
      this.starParticle.cx = this.x;
      this.starParticle.cy = this.y;

      // calling update
      this.starParticle.update();
    }
  }

  // METHOD: glitch effect
  glitchHandle() {
    // get current time in ms
    const currentTime = clock.getElapsedTime() * 1000;

    // if currently glitching
    if (this.isGlitching) {
      // check if glitch duration is over by comparing timestamps
      // if more than end time means glitch period ended
      if (currentTime > this.glitchEndTime) {
        // glitch = false
        this.isGlitching = false;
        // set next glitch time in 2 - 10 seconds
        this.nextGlitchTime =
          currentTime + (Math.random() * (60000 - 2000) + 2000);
        // set a new x and y coord within canvas with 5px boundary
        this.x = Math.random() * (cnv.width - 5 - 5 + 5);
        this.y = Math.random() * (cnv.height - 5 - 5 + 5);
      }
    }
    // if not glitching - check if time to glitch
    // if current time stamp is greater than next glitch time
    // means should be glitching
    else if (currentTime > this.nextGlitchTime) {
      this.isGlitching = true;
      // set glitch to randomly end in 2 - 6 seconds
      this.glitchEndTime =
        currentTime + (Math.random() * (60000 - 2000) + 2000);
    }
  }

  // check glitch status, particle pos, mouse pos, move the particle and draw
  update() {
    // call glitch handle method
    this.glitchHandle();

    // check particle is still within canvas
    if (this.x > cnv.width || this.x < 0) {
      // turn direction around
      this.dirX = -this.dirX;
    }
    if (this.y > cnv.height || this.y < 0) {
      // turn direction around
      this.dirY = -this.dirY;
    }

    // check for collision detection between mouse & particles
    // circle collision
    // ref: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection

    // checking distance between mouse & particle center point
    let dx = mouse.x - this.x;
    let dy = mouse.y - this.y;

    // a^2 + b^2 = c^2
    let dist = Math.sqrt(dx * dx + dy * dy);

    // checking that particle is far enough from edge of cvs
    // or it'll get stuck
    if (dist < mouse.radius + this.size) {
      // allowing buffer area of particle size (this.size) * 10
      // if mouse is left of particle
      if (mouse.x < this.x && this.x < cnv.width - this.size * 10) {
        // move particle to the right
        this.x += 10;
      }
      // if mouse is right of particle
      if (mouse.x > this.x && this.x > this.size * 10) {
        // move particle to the left
        this.x -= 10;
      }
      // if mouse is above particle
      if (mouse.y < this.y && this.y < cnv.height - this.size * 10) {
        // move particle down
        this.y += 10;
      }
      // if mouse is under particle
      if (mouse.y > this.y && this.y > this.size * 10) {
        // move particle up
        this.x -= 10;
      }
    }
    // moving all the other particles that aren't colliding along too
    this.x += this.dirX;
    this.y += this.dirY;
    // calling draw method to update;
    this.draw();
  }
}

// ----------------------------------------------------------------------- //
// INITIALISE
function init() {
  // number of particles
  let numOf = (cnv.height * cnv.width) / 7000;

  // loop to create values to create instaces of Particle to push into array
  // till num of particles reached
  for (let i = 0; i < numOf; i++) {
    // size of particle = random val between 1 & 5
    let size = Math.random() * (5 - 1) + 1;
    // x coord = random value between 0 and cnv width
    // with size * 2 as buffer so it doesn't get stuck
    let x =
      Math.random() * (cnv.width - size * 2 - (0 + size * 2)) + 0 + size * 2;
    let y =
      Math.random() * (cnv.height - size * 2 - (0 + size * 2)) + 0 + size * 2;

    // particle movement speed between -0.5 and 0.5
    let dirX = Math.random() * (1 + 0.5) - 0.5;
    let dirY = Math.random() * (1 + 0.5) - 0.5;

    // number of points on star
    // random value between 7 and 15
    let n = Math.random() * (15 - 7) + 7;

    // pushing a new instance of Particle with the above defined values
    // into particle array
    particleArr.push(new Particle(x, y, dirX, dirY, size, n));
  }

  // BACKGROUND
  // create a torus knot
  const geometry = new THREE.TorusKnotGeometry(5, 3, 40, 15, 14, 4);
  // Clear scene of previous meshes if filled
  if (mesh) scene.remove(mesh);
  // create new instance of mesh with torus knot and shader
  mesh = new THREE.Mesh(geometry, shaderMaterial);
  // add the mesh to scene
  scene.add(mesh);

  // add light
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
}

// ----------------------------------------------------------------------- //
// ANIMATION LOOP
function animate() {
  // call to check global glitch
  globalGlitchHandle();

  // if global glitch is active
  if (globalGlitchEvent === true) {
    // screen colour
    // clearing rect frame
    ctx.clearRect(0, 0, innerWidth, innerHeight);
    // colour
    ctx.fillStyle = "#" + colours[glitchCol];
    // draw rect
    ctx.fillRect(0, 0, innerWidth, innerHeight);
  }

  // Rotate three.js scene
  if (mesh) {
    mesh.rotation.x += 0.005;
    mesh.rotation.y += 0.01;
  }

  // updating uniform var in shader with the elapsed time of animation
  shaderMaterial.uniforms.u_time.value = clock.getElapsedTime();
  // render scene
  renderer.render(scene, camera);

  // update each star particle
  particleArr.forEach((e) => {
    e.update();
  });

  // call the connect func to draw lines
  connect();

  requestAnimationFrame(animate);
}

// call init fill array with randomised particles
init();
// call animate
animate();

// ----------------------------------------------------------------------- //
// web responsive
onresize = () => {
  cnv.width = innerWidth;
  cnv.height = innerHeight;
  mouse.radius = (cnv.height / 170) * (cnv.width / 170);

  // Update renderer and camera
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  init();
};

// ----------------------------------------------------------------------- //
// mouse out event
// particles stop trying to interact with mouse when it leaves canvas
window.addEventListener("mouseout", function (mouse_event) {
  mouse.x = undefined;
  mouse.y = undefined;
});

// ----------------------------------------------------------------------- //
// CLICK EVENT HANDLER
cnv.addEventListener("click", function cnvClicked() {
  console.log("screen clicked");
  // COLOUR
  // change colour index
  coli = coliRandomiser(coli);
  console.log(coli);

  // GLITCH (20% CHANCE)
  if (Math.random() < 0.2 && !globalGlitchEvent) {
    console.log("glitch is true");
    // start glitch
    globalGlitchEvent = true;
    // setting random background colour
    glitchCol = coliRandomiser(glitchCol);
    console.log(glitchCol);
    // set a random end time between 500-1500ms
    globalGlitchEndTime =
      clock.getElapsedTime() * 1000 + (Math.random() * (1500 - 500) + 500);
  }

  // SOUND
  if (audioContext.state == "suspended") {
    audioContext.resume();
  } else {
    audioE.play();
    let soundRatio = mouse.x / cnv.width;

    gainNode.gain.value = soundRatio;
  }
});

// ----------------------------------------------------------------------- //
// FUNC: CONNECT
// checking if particles are close enough to connect
function connect() {
  let opacityVal = 0.7;
  // go through every particle
  for (let a = 0; a < particleArr.length; a++) {
    // if star is glitching skip
    if (particleArr[a].isGlitching) continue;
    // going through consecutive particles in array
    for (let b = 0; b < particleArr.length; b++) {
      // if star is glitching skip
      if (particleArr[b].isGlitching) continue;
      let dist =
        (particleArr[a].x - particleArr[b].x) *
          (particleArr[a].x - particleArr[b].x) +
        (particleArr[a].y - particleArr[b].y) *
          (particleArr[a].y - particleArr[b].y);

      // the smaller the number, the longer the lines,
      // the more particles connected
      if (dist < (cnv.width / 2) * (cnv.height / 2)) {
        opacityVal = 0.7 - dist / 9000;
        ctx.strokeStyle = "rgba(51, 65, 57," + opacityVal + ")";
        ctx.lineWidth = 1;
        //console.log(ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(particleArr[a].x, particleArr[a].y);
        ctx.lineTo(particleArr[b].x, particleArr[b].y);
        ctx.stroke();
      }
    }
  }
}

// ----------------------------------------------------------------------- //
// FUNC: GLOBAL ANIMATION GLITCH HANDLE
function globalGlitchHandle() {
  // get current time in ms
  const currentTime = clock.getElapsedTime() * 1000;

  // If glitch is active
  if (globalGlitchEvent === true) {
    // check if glitch should end
    // if current time is greater than end time
    if (currentTime > globalGlitchEndTime) {
      // set glitch to false
      globalGlitchEvent = false;

      // restart the animation
      console.log("restarting animation");

      // clear particle array
      particleArr = [];

      // Clear scene
      if (mesh) scene.remove(mesh);

      // clear 2d ctx
      ctx.clearRect(0, 0, innerWidth, innerHeight);

      // re-initialize everything
      init();

      // Set next global glitch time - random val between 15-30 seconds
      nextGlobalGlitchTime =
        currentTime + (Math.random() * (30000 - 15000) + 15000);
    }
  }
  // if not in a global glitch state
  // check if current time is more than next glitch time
  // meaning it should be glitching
  else if (currentTime > nextGlobalGlitchTime) {
    console.log("global glitch true");
    // set glitch event to true
    globalGlitchEvent = true;

    // setting random background colour
    glitchCol = coliRandomiser(glitchCol);
    console.log(glitchCol);

    // set a random end time between 500ms-2s
    globalGlitchEndTime = currentTime + (Math.random() * (2000 - 500) + 500);
  }
}

// ----------------------------------------------------------------------- //
// FUNC: RANDOM COLOUR INDEX
function coliRandomiser(i) {
  // compute random colour index
  // new var to hold new colour index
  let newColi = Math.floor(Math.random() * colours.length);

  // if the new random index == the current index number
  // call the function again to get a new random index number
  // that is different
  if (newColi == i) {
    console.log("call recursive");
    return coliRandomiser(i);
  } else {
    // return new random index
    //newCol= r;
    return newColi;
  }
}
</script>
