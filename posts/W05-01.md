---
title: ðŸ’¥
published_at: 2025-04-08
snippet: Week 05 01
disable_html_sanitization: true
allow_math: true
---

<style>
  @import url('https://fonts.googleapis.com/css2?family=Cutive+Mono&display=swap');

h1, h3, h4, p, pre, ul, li {
  font-family: "Cutive Mono", monospace;
  font-weight: 700;
  font-style: normal;
  color:#CEB5D4;
}

 .text-gray-500, .markdown-body blockquote {color:#E872B0}
 .markdown-body {background-color:#102B53;}
  html {background-color:#102B53;}
  h1 {; font-weight: 800;}
  p, pre, ul {color:#7D9FC0;}
  .markdown-body a {color:#4E7AB1; text-decoration:underline;}
</style>

---

# Homework

> Work 1:

<div id="container1"></div>

<!-- --------------------------------------------------------------------- -->
<script type="module" >
  import * as THREE from '/scripts/threejs-master/build/three.module.js';

  import { AsciiEffect } from '/scripts/threejs-master/examples/jsm/effects/AsciiEffect.js';
	import { TrackballControls } from '/scripts/threejs-master/examples/jsm/controls/TrackballControls.js';


  console.log(THREE);

  const container = document.getElementById('container1');
  const width = container.parentNode.scrollWidth;
  const height = width * 9 / 16;
div.style.overflow = "hidden";
document.body.appendChild(container);

  let camera, controls, scene, renderer, effect;

  let sphere, plane;

  const start = Date.now();

  init();

  function init() {

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.y = 150;
    camera.position.z = 500;

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0, 0, 0 );

    const pointLight1 = new THREE.PointLight( 0xffffff, 3, 0, 0 );
    pointLight1.position.set( 500, 500, 500 );
    scene.add( pointLight1 );

    const pointLight2 = new THREE.PointLight( 0xffffff, 1, 0, 0 );
    pointLight2.position.set( - 500, - 500, - 500 );
    scene.add( pointLight2 );

    sphere = new THREE.Mesh( new THREE.SphereGeometry( 200, 20, 10 ), new THREE.MeshPhongMaterial( { flatShading: true } ) );
    scene.add( sphere );

    // Plane

    plane = new THREE.Mesh( new THREE.PlaneGeometry( 400, 400 ), new THREE.MeshBasicMaterial( { color: 0xe0e0e0 } ) );
    plane.position.y = - 200;
    plane.rotation.x = - Math.PI / 2;
    scene.add( plane );

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setAnimationLoop( animate );

    effect = new AsciiEffect( renderer, ' .:-+*=%@#', { invert: true } );
    effect.setSize( window.innerWidth, window.innerHeight );
    effect.domElement.style.color = 'white';
    effect.domElement.style.backgroundColor = '#102B53';

    // Special case: append effect.domElement, instead of renderer.domElement.
    // AsciiEffect creates a custom domElement (a div container) where the ASCII elements are placed.

    document.body.appendChild( effect.domElement );

    controls = new TrackballControls( camera, effect.domElement );

    //

    window.addEventListener( 'resize', onWindowResize );

  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
    effect.setSize( window.innerWidth, window.innerHeight );

  }

  //

  function animate() {

    const timer = Date.now() - start;

    sphere.position.y = Math.abs( Math.sin( timer * 0.002 ) ) * 150;
    sphere.rotation.x = timer * 0.0003;
    sphere.rotation.z = timer * 0.0002;

    controls.update();

    effect.render( scene, camera );

  }
  
</script>

<!-- --------------------------------------------------------------------- -->

> Work 2:

<div id="container2"> </div>

> Work 3:

<div id="container3"> </div>

<!-- --------------------------------------------------------------------- -->
<script type="module">
  import * as THREE from '/scripts/threejs-master/build/three.module.js';

  import Stats from '/scripts/threejs-master/examples/jsm/libs/stats.module.js';

  import { OrbitControls } from '/scripts/threejs-master/examples/jsm/controls/OrbitControls.js';
  import { RoomEnvironment } from '/scripts/threejs-master/examples/jsm/environments/RoomEnvironment.js';

  import { GLTFLoader } from '/scripts/threejs-master/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from '/scripts/threejs-master/examples/jsm/loaders/DRACOLoader.js';


  const container = document.getElementById('container2');
  const width = container.parentNode.scrollWidth;
  const height = width * 9 / 16;

let mixer;

const clock = new THREE.Clock();
const container = document.getElementById( 'container' );

const stats = new Stats();
container.appendChild( stats.dom );

const renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
container.appendChild( renderer.domElement );

const pmremGenerator = new THREE.PMREMGenerator( renderer );

const scene = new THREE.Scene();
scene.background = new THREE.Color( 0xbfe3dd );
scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;

const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
camera.position.set( 5, 2, 8 );

const controls = new OrbitControls( camera, renderer.domElement );
controls.target.set( 0, 0.5, 0 );
controls.update();
controls.enablePan = false;
controls.enableDamping = true;

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

const loader = new GLTFLoader();
loader.setDRACOLoader( dracoLoader );
loader.load( 'models/gltf/LittlestTokyo.glb', function ( gltf ) {

  const model = gltf.scene;
  model.position.set( 1, 1, 0 );
  model.scale.set( 0.01, 0.01, 0.01 );
  scene.add( model );

  mixer = new THREE.AnimationMixer( model );
  mixer.clipAction( gltf.animations[ 0 ] ).play();

  renderer.setAnimationLoop( animate );

}, undefined, function ( e ) {

  console.error( e );

} );


window.onresize = function () {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( window.innerWidth, window.innerHeight );

};


function animate() {

  const delta = clock.getDelta();

  mixer.update( delta );

  controls.update();

  stats.update();

  renderer.render( scene, camera );

}

</script>
