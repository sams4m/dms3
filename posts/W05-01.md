---
title: ðŸ’¥ Three js
published_at: 2025-04-08
snippet: Week 05 01
disable_html_sanitization: true
allow_math: true
---

<style>
  @import url('https://fonts.googleapis.com/css2?family=Cutive+Mono&display=swap');

h1, h3, h4, p, pre, ul, li {
  font-family: "Cutive Mono", monospace;
  font-weight: 700;
  font-style: normal;
  color:#CEB5D4;
}

 .text-gray-500, .markdown-body blockquote {color:#E872B0}
 .markdown-body {background-color:#102B53;}
  html {background-color:#102B53;}
  h1 {; font-weight: 800;}
  p, pre, ul {color:#7D9FC0;}
  .markdown-body a {color:#4E7AB1; text-decoration:underline;}
</style>

---

# Homework

> Work 1:

<div id="container1" style= "height:300px;"> </div>

<br>

> Work 2:

<div id="container2"></div>

<br>

> Work 3:

<div id="container3" > </div>

<!-- SCRIPT: ASCII BALL --------------------------------------------------------------------- -->
<script type="module" >
  import * as THREE from '/scripts/threejs-master/build/three.module.js';

  import { AsciiEffect } from '/scripts/threejs-master/examples/jsm/effects/AsciiEffect.js';
  import { TrackballControls } from '/scripts/threejs-master/examples/jsm/controls/TrackballControls.js';

  console.log(THREE);

  const container = document.getElementById('container1');
  //const width = container.parentNode.innerWidth;
  //const height = width * 9 / 16;

  let camera, controls, scene, renderer, effect;

  let sphere, plane;

  const start = Date.now();

  init();

  function init() {

    camera = new THREE.PerspectiveCamera( 70, container.clientWidth / container.clientHeight, 1, 1000 );
    camera.position.y = 150;
    camera.position.z = 500;

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0, 0, 0 );

    const pointLight1 = new THREE.PointLight( 0xffffff, 3, 0, 0 );
    pointLight1.position.set( 500, 500, 500 );
    scene.add( pointLight1 );

    const pointLight2 = new THREE.PointLight( 0xffffff, 1, 0, 0 );
    pointLight2.position.set( - 500, - 500, - 500 );
    scene.add( pointLight2 );

    sphere = new THREE.Mesh( new THREE.SphereGeometry( 200, 20, 10 ), new THREE.MeshPhongMaterial( { flatShading: true } ) );
    scene.add( sphere );

    // Plane

    plane = new THREE.Mesh( new THREE.PlaneGeometry( 400, 400 ), new THREE.MeshBasicMaterial( { color: 0xe0e0e0 } ) );
    plane.position.y = - 200;
    plane.rotation.x = - Math.PI / 2;
    scene.add( plane );

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( container.clientWidth, container.clientHeight );
    renderer.setAnimationLoop( animate );

    effect = new AsciiEffect( renderer, ' .:-+*=%@#', { invert: true } );
    effect.setSize( container.clientWidth, container.clientHeight );
    renderer.domElement.style.color = 'white';
    renderer.domElement.style.backgroundColor = '#102B53';

    // Special case: append effect.domElement, instead of renderer.domElement.
    // AsciiEffect creates a custom domElement (a div container) where the ASCII elements are placed.

    container.appendChild( effect.domElement );

    controls = new TrackballControls( camera, effect.domElement );

    //

    window.addEventListener( 'resize', onWindowResize );

  }

  function onWindowResize() {

    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( container.clientWidth, container.clientHeight );
    effect.setSize( container.clientWidth, container.clientHeight );

    renderer.domElement.style.color = 'white';
    renderer.domElement.style.backgroundColor = '#102B53';

  }

  //

  function animate() {

    const timer = Date.now() - start;

    sphere.position.y = Math.abs( Math.sin( timer * 0.002 ) ) * 150;
    sphere.rotation.x = timer * 0.0003;
    sphere.rotation.z = timer * 0.0002;

    controls.update();

    effect.render( scene, camera );

  }
  
</script>

<!-- SCRIPT: CUBES --------------------------------------------------------------------- -->
<script type="module">
  import * as THREE from '/scripts/threejs-master/build/three.module.js';
  import { PeppersGhostEffect } from '/scripts/threejs-master/examples/jsm/effects/PeppersGhostEffect.js';

  

let camera, scene, renderer, effect;
let group;

init();

function init() {

  const container = document.getElementById('container2');

  camera = new THREE.PerspectiveCamera( 60,container.clientWidth / container.clientHeight, 1, 100000 );

  scene = new THREE.Scene();

  group = new THREE.Group();
  scene.add( group );

  // Cube

  const geometry = new THREE.BoxGeometry().toNonIndexed(); // ensure unique vertices for each triangle

  const position = geometry.attributes.position;
  const colors = [];
  const color = new THREE.Color();

  // generate for each side of the cube a different color

  for ( let i = 0; i < position.count; i += 6 ) {

    color.setHex( Math.random() * 0xffffff );

    // first face

    colors.push( color.r, color.g, color.b );
    colors.push( color.r, color.g, color.b );
    colors.push( color.r, color.g, color.b );

    // second face

    colors.push( color.r, color.g, color.b );
    colors.push( color.r, color.g, color.b );
    colors.push( color.r, color.g, color.b );

  }

  geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

  const material = new THREE.MeshBasicMaterial( { vertexColors: true } );

  for ( let i = 0; i < 10; i ++ ) {

    const cube = new THREE.Mesh( geometry, material );
    cube.position.x = Math.random() * 2 - 1;
    cube.position.y = Math.random() * 2 - 1;
    cube.position.z = Math.random() * 2 - 1;
    cube.scale.multiplyScalar( Math.random() + 0.5 );
    group.add( cube );

  }

  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setAnimationLoop( animate );
  container.appendChild( renderer.domElement );
  renderer.setSize(container.clientWidth, container.clientHeight);

  effect = new PeppersGhostEffect( renderer );
  effect.setSize( container.clientWidth, container.clientHeight );
  effect.cameraDistance = 5;
  

  window.addEventListener( 'resize', onWindowResize );

}

function onWindowResize() {

  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(container.clientWidth, container.clientHeight);
  effect.setSize( container.clientWidth, container.clientHeight);
}

function animate() {

  group.rotation.y += 0.01;

  effect.render( scene, camera );

}
</script>

<!-- SCRIPT: --------------------------------------------------------------------- -->

<script type="module">

import * as THREE from '/scripts/threejs-master/build/three.module.js';

import Stats from 'https://cdn.jsdelivr.net/npm/stats-gl@3.6.0/dist/main.js';

import { GUI } from '/scripts/threejs-master/examples/jsm/libs/lil-gui.module.min.js';
import { OrbitControls } from '/scripts/threejs-master/examples/jsm/controls/OrbitControls.js';
import { Line2 } from '/scripts/threejs-master/examples/jsm/lines/Line2.js';
import { LineMaterial } from '/scripts/threejs-master/examples/jsm/lines/LineMaterial.js';
import { LineGeometry } from '/scripts/threejs-master/examples/jsm/lines/LineGeometry.js';
import * as GeometryUtils from '/scripts/threejs-master/examples/jsm/utils/GeometryUtils.js';

let line, renderer, scene, camera, camera2, controls;
let line1;
let matLine, matLineBasic, matLineDashed;
let stats;
let gui;

// viewport
let insetWidth;
let insetHeight;

init();

function init() {

  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( container.clientWidth, container.clientHeight );
  renderer.setClearColor( 0x000000, 0.0 );
  renderer.setAnimationLoop( animate );
  document.body.appendChild( renderer.domElement );

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera( 40, container.clientWidth / container.clientHeight, 1, 1000 );
  camera.position.set( - 40, 0, 60 );

  camera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );
  camera2.position.copy( camera.position );

  controls = new OrbitControls( camera, renderer.domElement );
  controls.enableDamping = true;
  controls.minDistance = 10;
  controls.maxDistance = 500;


  // Position and THREE.Color Data

  const positions = [];
  const colors = [];

  const points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );

  const spline = new THREE.CatmullRomCurve3( points );
  const divisions = Math.round( 12 * points.length );
  const point = new THREE.Vector3();
  const color = new THREE.Color();

  for ( let i = 0, l = divisions; i < l; i ++ ) {

    const t = i / l;

    spline.getPoint( t, point );
    positions.push( point.x, point.y, point.z );

    color.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );
    colors.push( color.r, color.g, color.b );

  }


  // Line2 ( LineGeometry, LineMaterial )

  const geometry = new LineGeometry();
  geometry.setPositions( positions );
  geometry.setColors( colors );

  matLine = new LineMaterial( {

    color: 0xffffff,
    linewidth: 5, // in world units with size attenuation, pixels otherwise
    vertexColors: true,

    dashed: false,
    alphaToCoverage: true,

  } );

  line = new Line2( geometry, matLine );
  line.computeLineDistances();
  line.scale.set( 1, 1, 1 );
  scene.add( line );


  // THREE.Line ( THREE.BufferGeometry, THREE.LineBasicMaterial ) - rendered with gl.LINE_STRIP

  const geo = new THREE.BufferGeometry();
  geo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
  geo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

  matLineBasic = new THREE.LineBasicMaterial( { vertexColors: true } );
  matLineDashed = new THREE.LineDashedMaterial( { vertexColors: true, scale: 2, dashSize: 1, gapSize: 1 } );

  line1 = new THREE.Line( geo, matLineBasic );
  line1.computeLineDistances();
  line1.visible = false;
  scene.add( line1 );

  //

  window.addEventListener( 'resize', onWindowResize );
  onWindowResize();

  stats = new Stats( { horizontal: false, trackGPU: true } );
  stats.init( renderer );
  document.body.appendChild( stats.dom );

  initGui();

}

function onWindowResize() {

  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( container.clientWidth, container.clientHeight );

  insetWidth = container.clientHeight / 4; // square
  insetHeight = container.clientHeight / 4;

  camera2.aspect = insetWidth / insetHeight;
  camera2.updateProjectionMatrix();

}

function animate() {

  // main scene

  renderer.setClearColor( 0x000000, 0 );

  renderer.setViewport( 0, 0, container.clientWidth, container.clientHeight );

  controls.update();

  renderer.render( scene, camera );

  // inset scene

  renderer.setClearColor( 0x222222, 1 );

  renderer.clearDepth(); // important!

  renderer.setScissorTest( true );

  renderer.setScissor( 20, 20, insetWidth, insetHeight );

  renderer.setViewport( 20, 20, insetWidth, insetHeight );

  camera2.position.copy( camera.position );
  camera2.quaternion.copy( camera.quaternion );

  renderer.render( scene, camera2 );

  renderer.setScissorTest( false );

  stats.update();

}

//

function initGui() {

  gui = new GUI();

  const param = {
    'line type': 0,
    'world units': false,
    'width': 5,
    'alphaToCoverage': true,
    'dashed': false,
    'dash scale': 1,
    'dash / gap': 1
  };

  gui.add( param, 'line type', { 'LineGeometry': 0, 'gl.LINE': 1 } ).onChange( function ( val ) {

    switch ( val ) {

      case 0:
        line.visible = true;

        line1.visible = false;

        break;

      case 1:
        line.visible = false;

        line1.visible = true;

        break;

    }

  } );

  gui.add( param, 'world units' ).onChange( function ( val ) {

    matLine.worldUnits = val;
    matLine.needsUpdate = true;

  } );

  gui.add( param, 'width', 1, 10 ).onChange( function ( val ) {

    matLine.linewidth = val;

  } );

  gui.add( param, 'alphaToCoverage' ).onChange( function ( val ) {

    matLine.alphaToCoverage = val;

  } );

  gui.add( param, 'dashed' ).onChange( function ( val ) {

    matLine.dashed = val;
    line1.material = val ? matLineDashed : matLineBasic;

  } );

  gui.add( param, 'dash scale', 0.5, 2, 0.1 ).onChange( function ( val ) {

    matLine.dashScale = val;
    matLineDashed.scale = val;

  } );

  gui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {

    switch ( val ) {

      case 0:
        matLine.dashSize = 2;
        matLine.gapSize = 1;

        matLineDashed.dashSize = 2;
        matLineDashed.gapSize = 1;

        break;

      case 1:
        matLine.dashSize = 1;
        matLine.gapSize = 1;

        matLineDashed.dashSize = 1;
        matLineDashed.gapSize = 1;

        break;

      case 2:
        matLine.dashSize = 1;
        matLine.gapSize = 2;

        matLineDashed.dashSize = 1;
        matLineDashed.gapSize = 2;

        break;

    }

  } );

}

</script>
